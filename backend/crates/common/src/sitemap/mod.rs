//! Sitemap module for integration tests
//!
//! Provides Rust bindings to the sitemap.json generated by @ppt/sitemap.
//! This allows backend tests to validate API endpoints against the sitemap.

use serde::Deserialize;

/// Embedded sitemap JSON at compile time
const SITEMAP_JSON: &str = include_str!("../../../../../frontend/packages/sitemap/src/json/sitemap.json");

/// Authentication requirement for a route or endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct AuthRequirement {
    pub required: bool,
    pub roles: Option<Vec<String>>,
    pub scopes: Option<Vec<String>>,
    #[serde(rename = "mfaRequired")]
    pub mfa_required: Option<bool>,
    #[serde(rename = "tenantContext")]
    pub tenant_context: Option<TenantContext>,
    pub permissions: Option<Vec<String>>,
}

/// Tenant context requirements
#[derive(Debug, Clone, Deserialize)]
pub struct TenantContext {
    pub required: bool,
    #[serde(rename = "headerName")]
    pub header_name: Option<String>,
}

/// Route parameter definition
#[derive(Debug, Clone, Deserialize)]
pub struct RouteParam {
    pub name: String,
    #[serde(rename = "type")]
    pub param_type: String,
    pub description: Option<String>,
    pub required: bool,
    pub example: Option<String>,
}

/// Frontend route definition
#[derive(Debug, Clone, Deserialize)]
pub struct FrontendRoute {
    pub id: String,
    pub app: String,
    pub path: String,
    pub name: String,
    pub description: Option<String>,
    pub params: Option<Vec<RouteParam>>,
    pub auth: AuthRequirement,
    #[serde(rename = "apiEndpoints")]
    pub api_endpoints: Option<Vec<String>>,
    pub component: Option<String>,
    #[serde(rename = "parentId")]
    pub parent_id: Option<String>,
    pub feature: Option<String>,
    pub tags: Option<Vec<String>>,
}

/// Mobile screen definition
#[derive(Debug, Clone, Deserialize)]
pub struct MobileScreen {
    pub id: String,
    pub app: String,
    #[serde(rename = "screenName")]
    pub screen_name: String,
    pub name: String,
    pub description: Option<String>,
    pub tab: Option<String>,
    #[serde(rename = "tabIcon")]
    pub tab_icon: Option<String>,
    pub auth: AuthRequirement,
    #[serde(rename = "apiEndpoints")]
    pub api_endpoints: Option<Vec<String>>,
    pub component: Option<String>,
    pub feature: Option<String>,
    pub tags: Option<Vec<String>>,
}

/// Response schema
#[derive(Debug, Clone, Deserialize)]
pub struct ResponseSchema {
    #[serde(rename = "statusCode")]
    pub status_code: u16,
    pub description: String,
    #[serde(rename = "ref")]
    pub schema_ref: Option<String>,
}

/// API endpoint definition
#[derive(Debug, Clone, Deserialize)]
pub struct ApiEndpoint {
    #[serde(rename = "operationId")]
    pub operation_id: String,
    pub server: String,
    pub method: String,
    pub path: String,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "pathParams")]
    pub path_params: Option<Vec<RouteParam>>,
    #[serde(rename = "queryParams")]
    pub query_params: Option<Vec<RouteParam>>,
    pub responses: Vec<ResponseSchema>,
    pub auth: AuthRequirement,
    pub feature: Option<String>,
}

/// User flow step
#[derive(Debug, Clone, Deserialize)]
pub struct FlowStep {
    pub order: u32,
    pub name: String,
    pub description: Option<String>,
    pub route: Option<String>,
    #[serde(rename = "apiCall")]
    pub api_call: Option<String>,
}

/// User flow definition
#[derive(Debug, Clone, Deserialize)]
pub struct UserFlow {
    pub id: String,
    pub name: String,
    pub apps: Vec<String>,
    pub description: Option<String>,
    pub category: String,
    #[serde(rename = "requiredRole")]
    pub required_role: String,
    pub prerequisites: Option<Vec<String>>,
    pub steps: Vec<FlowStep>,
    #[serde(rename = "useCases")]
    pub use_cases: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
}

/// Sitemap metadata
#[derive(Debug, Clone, Deserialize)]
pub struct SitemapMetadata {
    pub generated_at: String,
    pub version: String,
    pub stats: SitemapStats,
}

/// Sitemap statistics
#[derive(Debug, Clone, Deserialize)]
pub struct SitemapStats {
    pub ppt_web_routes: usize,
    pub reality_web_routes: usize,
    pub mobile_screens: usize,
    pub api_server_endpoints: usize,
    pub reality_server_endpoints: usize,
    pub flows: usize,
}

/// Routes container
#[derive(Debug, Clone, Deserialize)]
pub struct Routes {
    #[serde(rename = "ppt-web")]
    pub ppt_web: Vec<FrontendRoute>,
    #[serde(rename = "reality-web")]
    pub reality_web: Vec<FrontendRoute>,
}

/// Screens container
#[derive(Debug, Clone, Deserialize)]
pub struct Screens {
    pub mobile: Vec<MobileScreen>,
}

/// Endpoints container
#[derive(Debug, Clone, Deserialize)]
pub struct Endpoints {
    #[serde(rename = "api-server")]
    pub api_server: Vec<ApiEndpoint>,
    #[serde(rename = "reality-server")]
    pub reality_server: Vec<ApiEndpoint>,
}

/// Complete sitemap structure
#[derive(Debug, Clone, Deserialize)]
pub struct Sitemap {
    pub routes: Routes,
    pub screens: Screens,
    pub endpoints: Endpoints,
    pub flows: Vec<UserFlow>,
    pub metadata: SitemapMetadata,
}

impl Sitemap {
    /// Load sitemap from embedded JSON
    pub fn load() -> Self {
        serde_json::from_str(SITEMAP_JSON).expect("Failed to parse sitemap.json")
    }

    /// Get an API endpoint by operation ID
    pub fn get_endpoint(&self, server: &str, operation_id: &str) -> Option<&ApiEndpoint> {
        let endpoints = match server {
            "api-server" => &self.endpoints.api_server,
            "reality-server" => &self.endpoints.reality_server,
            _ => return None,
        };
        endpoints.iter().find(|e| e.operation_id == operation_id)
    }

    /// Get all protected endpoints for a server
    pub fn get_protected_endpoints(&self, server: &str) -> Vec<&ApiEndpoint> {
        let endpoints = match server {
            "api-server" => &self.endpoints.api_server,
            "reality-server" => &self.endpoints.reality_server,
            _ => return vec![],
        };
        endpoints.iter().filter(|e| e.auth.required).collect()
    }

    /// Get all public endpoints for a server
    pub fn get_public_endpoints(&self, server: &str) -> Vec<&ApiEndpoint> {
        let endpoints = match server {
            "api-server" => &self.endpoints.api_server,
            "reality-server" => &self.endpoints.reality_server,
            _ => return vec![],
        };
        endpoints.iter().filter(|e| !e.auth.required).collect()
    }

    /// Get endpoints by tag
    pub fn get_endpoints_by_tag(&self, server: &str, tag: &str) -> Vec<&ApiEndpoint> {
        let endpoints = match server {
            "api-server" => &self.endpoints.api_server,
            "reality-server" => &self.endpoints.reality_server,
            _ => return vec![],
        };
        endpoints
            .iter()
            .filter(|e| e.tags.as_ref().map_or(false, |t| t.contains(&tag.to_string())))
            .collect()
    }

    /// Get a user flow by ID
    pub fn get_flow(&self, id: &str) -> Option<&UserFlow> {
        self.flows.iter().find(|f| f.id == id)
    }

    /// Get all flows for a category
    pub fn get_flows_by_category(&self, category: &str) -> Vec<&UserFlow> {
        self.flows.iter().filter(|f| f.category == category).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_sitemap() {
        let sitemap = Sitemap::load();
        assert!(!sitemap.routes.ppt_web.is_empty());
        assert!(!sitemap.routes.reality_web.is_empty());
        assert!(!sitemap.screens.mobile.is_empty());
        assert!(!sitemap.endpoints.api_server.is_empty());
        assert!(!sitemap.endpoints.reality_server.is_empty());
        assert!(!sitemap.flows.is_empty());
    }

    #[test]
    fn test_get_endpoint() {
        let sitemap = Sitemap::load();
        let endpoint = sitemap.get_endpoint("api-server", "auth_login");
        assert!(endpoint.is_some());
        let ep = endpoint.unwrap();
        assert_eq!(ep.method, "POST");
        assert_eq!(ep.path, "/api/v1/auth/login");
        assert!(!ep.auth.required);
    }

    #[test]
    fn test_protected_endpoints() {
        let sitemap = Sitemap::load();
        let protected = sitemap.get_protected_endpoints("api-server");
        assert!(!protected.is_empty());
        assert!(protected.iter().all(|e| e.auth.required));
    }

    #[test]
    fn test_public_endpoints() {
        let sitemap = Sitemap::load();
        let public = sitemap.get_public_endpoints("api-server");
        assert!(!public.is_empty());
        assert!(public.iter().all(|e| !e.auth.required));
    }

    #[test]
    fn test_get_flow() {
        let sitemap = Sitemap::load();
        let flow = sitemap.get_flow("flow-login-basic");
        assert!(flow.is_some());
        let f = flow.unwrap();
        assert_eq!(f.category, "authentication");
        assert!(!f.steps.is_empty());
    }

    #[test]
    fn test_metadata() {
        let sitemap = Sitemap::load();
        assert_eq!(sitemap.metadata.stats.ppt_web_routes, 13);
        assert_eq!(sitemap.metadata.stats.reality_web_routes, 9);
        assert_eq!(sitemap.metadata.stats.mobile_screens, 6);
    }
}
